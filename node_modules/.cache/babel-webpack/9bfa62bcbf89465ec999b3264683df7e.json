{"ast":null,"code":"import { Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { of, Observable, from } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * Generated from: auth.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// WARNING: interface has both a type and a value, skipping emit\n\nimport * as ɵngcc0 from '@angular/core';\nlet AngularFireAuth = /*#__PURE__*/(() => {\n  class AngularFireAuth {\n    /**\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} platformId\n     * @param {?} zone\n     */\n    constructor(options, nameOrConfig, // tslint:disable-next-line:ban-types\n    platformId, zone) {\n      /** @type {?} */\n      const schedulers = new ɵAngularFireSchedulers(zone);\n      /** @type {?} */\n\n      const keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(schedulers);\n      /** @type {?} */\n\n      const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n      /**\n      * @return {?}\n      */\n      () => zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => import('firebase/auth'))), map(\n      /**\n      * @return {?}\n      */\n      () => ɵfirebaseAppFactory(options, zone, nameOrConfig)), map(\n      /**\n      * @param {?} app\n      * @return {?}\n      */\n      app => zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => app.auth())), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n\n      if (isPlatformServer(platformId)) {\n        this.authState = this.user = this.idToken = this.idTokenResult = of(null);\n      } else {\n        // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n        //       (e.g, `import { auth } from 'firebase/app'`) are getting an undefined auth object unexpectedly\n        //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n        //       There could potentially be race conditions still... but this greatly decreases the odds while\n        //       we reevaluate the API.\n\n        /** @type {?} */\n        const _ = auth.pipe(first()).subscribe();\n\n        this.authState = auth.pipe(switchMap(\n        /**\n        * @param {?} auth\n        * @return {?}\n        */\n        auth => auth.getRedirectResult().then(\n        /**\n        * @return {?}\n        */\n        () => auth,\n        /**\n        * @return {?}\n        */\n        () => auth)), switchMap(\n        /**\n        * @param {?} auth\n        * @return {?}\n        */\n        auth => zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        () => new Observable(auth.onAuthStateChanged.bind(auth)))), keepUnstableUntilFirst);\n        this.user = auth.pipe(switchMap(\n        /**\n        * @param {?} auth\n        * @return {?}\n        */\n        auth => auth.getRedirectResult().then(\n        /**\n        * @return {?}\n        */\n        () => auth,\n        /**\n        * @return {?}\n        */\n        () => auth)), switchMap(\n        /**\n        * @param {?} auth\n        * @return {?}\n        */\n        auth => zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        () => new Observable(auth.onIdTokenChanged.bind(auth)))), keepUnstableUntilFirst);\n        this.idToken = this.user.pipe(switchMap(\n        /**\n        * @param {?} user\n        * @return {?}\n        */\n        user => user ? from(user.getIdToken()) : of(null)));\n        this.idTokenResult = this.user.pipe(switchMap(\n        /**\n        * @param {?} user\n        * @return {?}\n        */\n        user => user ? from(user.getIdTokenResult()) : of(null)));\n      }\n\n      return ɵlazySDKProxy(this, auth, zone);\n    }\n\n  }\n\n  AngularFireAuth.ɵfac = function AngularFireAuth_Factory(t) {\n    return new (t || AngularFireAuth)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  AngularFireAuth.ɵprov = ɵɵdefineInjectable({\n    factory: function AngularFireAuth_Factory() {\n      return new AngularFireAuth(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone));\n    },\n    token: AngularFireAuth,\n    providedIn: \"any\"\n  });\n  return AngularFireAuth;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * Observable of authentication state; as of Firebase 4.0 this is only triggered via sign-in/out\n   * @type {?}\n   */\n  AngularFireAuth.prototype.authState;\n  /**\n   * Observable of the currently signed-in user's JWT token used to identify the user to a Firebase service (or null).\n   * @type {?}\n   */\n\n  AngularFireAuth.prototype.idToken;\n  /**\n   * Observable of the currently signed-in user (or null).\n   * @type {?}\n   */\n\n  AngularFireAuth.prototype.user;\n  /**\n   * Observable of the currently signed-in user's IdTokenResult object which contains the ID token JWT string and other\n   * helper properties for getting different data associated with the token as well as all the decoded payload claims\n   * (or null).\n   * @type {?}\n   */\n\n  AngularFireAuth.prototype.idTokenResult;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: auth.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet AngularFireAuthModule = /*#__PURE__*/(() => {\n  class AngularFireAuthModule {}\n\n  AngularFireAuthModule.ɵfac = function AngularFireAuthModule_Factory(t) {\n    return new (t || AngularFireAuthModule)();\n  };\n\n  AngularFireAuthModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireAuthModule\n  });\n  AngularFireAuthModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [AngularFireAuth]\n  });\n  return AngularFireAuthModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-auth.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireAuth, AngularFireAuthModule }; //# sourceMappingURL=angular-fire-auth.js.map","map":null,"metadata":{},"sourceType":"module"}