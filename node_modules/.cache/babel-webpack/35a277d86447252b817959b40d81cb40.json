{"ast":null,"code":"import { queueScheduler, asyncScheduler } from 'rxjs';\nimport { tap, subscribeOn, observeOn } from 'rxjs/operators';\nimport { InjectionToken, Version, NgZone, Optional, VERSION as VERSION$1, NgModule, Inject, PLATFORM_ID } from '@angular/core';\nimport firebase from 'firebase/app';\n/**\n * @fileoverview added by tsickle\n * Generated from: angularfire2.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction noop() {}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\n\n\nclass ɵZoneScheduler {\n  /**\n   * @param {?} zone\n   * @param {?=} delegate\n   */\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  now() {\n    return this.delegate.now();\n  }\n  /**\n   * @param {?} work\n   * @param {?=} delay\n   * @param {?=} state\n   * @return {?}\n   */\n\n\n  schedule(work, delay, state) {\n    /** @type {?} */\n    const targetZone = this.zone; // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n\n    /** @type {?} */\n\n    const workInZone =\n    /**\n    * @this {?}\n    * @param {?} state\n    * @return {?}\n    */\n    function (state) {\n      targetZone.runGuarded(\n      /**\n      * @return {?}\n      */\n      () => {\n        work.apply(this, [state]);\n      });\n    }; // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n\n\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ɵZoneScheduler.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ɵZoneScheduler.prototype.delegate;\n} // tslint:disable-next-line:class-name\n\n/**\n * @template T\n */\n\n\nclass ɵBlockUntilFirstOperator {\n  /**\n   * @param {?} zone\n   */\n  constructor(zone) {\n    this.zone = zone;\n    this.task = null;\n  }\n  /**\n   * @param {?} subscriber\n   * @param {?} source\n   * @return {?}\n   */\n\n\n  call(subscriber, source) {\n    /** @type {?} */\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(\n    /**\n    * @return {?}\n    */\n    () => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n    return source.pipe(tap({\n      next: unscheduleTask,\n      complete: unscheduleTask,\n      error: unscheduleTask\n    })).subscribe(subscriber).add(unscheduleTask);\n  }\n  /**\n   * @private\n   * @return {?}\n   */\n\n\n  unscheduleTask() {\n    // maybe this is a race condition, invoke in a timeout\n    // hold for 10ms while I try to figure out what is going on\n    setTimeout(\n    /**\n    * @return {?}\n    */\n    () => {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }, 10);\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ɵBlockUntilFirstOperator.prototype.task;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ɵBlockUntilFirstOperator.prototype.zone;\n} // tslint:disable-next-line:class-name\n\n\nclass ɵAngularFireSchedulers {\n  /**\n   * @param {?} ngZone\n   */\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.outsideAngular = ngZone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(\n    /**\n    * @return {?}\n    */\n    () => new ɵZoneScheduler(Zone.current, asyncScheduler));\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  ɵAngularFireSchedulers.prototype.outsideAngular;\n  /** @type {?} */\n\n  ɵAngularFireSchedulers.prototype.insideAngular;\n  /** @type {?} */\n\n  ɵAngularFireSchedulers.prototype.ngZone;\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n * @param {?} schedulers\n * @return {?}\n */\n\n\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n  return (\n    /**\n    * @template T\n    * @param {?} obs$\n    * @return {?}\n    */\n    function keepUnstableUntilFirst(obs$) {\n      obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n      return obs$.pipe( // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n      subscribeOn(schedulers.outsideAngular), // Run operators inside the angular zone (e.g. side effects via tap())\n      observeOn(schedulers.insideAngular) // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n      // share()\n      );\n    }\n  );\n} // DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\n\n/** @type {?} */\n\n\nconst noopFunctions = ['ngOnDestroy']; // INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\n\n/** @type {?} */\n\nconst ɵlazySDKProxy =\n/**\n* @param {?} klass\n* @param {?} observable\n* @param {?} zone\n* @return {?}\n*/\n(klass, observable, zone) => {\n  return new Proxy(klass, {\n    get:\n    /**\n    * @param {?} _\n    * @param {?} name\n    * @return {?}\n    */\n    (_, name) => zone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => {\n      if (klass[name]) {\n        return klass[name];\n      }\n\n      if (noopFunctions.includes(name)) {\n        return (\n          /**\n          * @return {?}\n          */\n          () => {}\n        );\n      }\n      /** @type {?} */\n\n\n      const promise = observable.toPromise().then(\n      /**\n      * @param {?} mod\n      * @return {?}\n      */\n      mod => {\n        /** @type {?} */\n        const ret = mod && mod[name]; // TODO move to proper type guards\n\n        if (typeof ret === 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then(\n          /**\n          * @param {?} res\n          * @return {?}\n          */\n          res => zone.run(\n          /**\n          * @return {?}\n          */\n          () => res));\n        } else {\n          return zone.run(\n          /**\n          * @return {?}\n          */\n          () => ret);\n        }\n      }); // recurse the proxy\n\n      return new Proxy(\n      /**\n      * @return {?}\n      */\n      () => undefined, {\n        get:\n        /**\n        * @param {?} _\n        * @param {?} name\n        * @return {?}\n        */\n        (_, name) => promise[name],\n        // TODO handle callbacks as transparently as I can\n        apply:\n        /**\n        * @param {?} self\n        * @param {?} _\n        * @param {?} args\n        * @return {?}\n        */\n        (self, _, args) => promise.then(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        it => it && it(...args))\n      });\n    })\n  });\n};\n/**\n * @fileoverview added by tsickle\n * Generated from: firebase.app.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction FirebaseOptions() {}\n/**\n * @record\n */\n\n\nfunction FirebaseAppConfig() {}\n/** @type {?} */\n\n\nconst FIREBASE_OPTIONS = /*#__PURE__*/new InjectionToken('angularfire2.app.options');\n/** @type {?} */\n\nconst FIREBASE_APP_NAME = /*#__PURE__*/new InjectionToken('angularfire2.app.nameOrConfig'); // Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\n\nclass FirebaseApp {}\n\nif (false) {\n  /** @type {?} */\n  FirebaseApp.prototype.name;\n  /** @type {?} */\n\n  FirebaseApp.prototype.options;\n  /** @type {?} */\n\n  FirebaseApp.prototype.analytics;\n  /** @type {?} */\n\n  FirebaseApp.prototype.auth;\n  /** @type {?} */\n\n  FirebaseApp.prototype.database;\n  /** @type {?} */\n\n  FirebaseApp.prototype.messaging;\n  /** @type {?} */\n\n  FirebaseApp.prototype.performance;\n  /** @type {?} */\n\n  FirebaseApp.prototype.storage;\n  /** @type {?} */\n\n  FirebaseApp.prototype.delete;\n  /** @type {?} */\n\n  FirebaseApp.prototype.firestore;\n  /** @type {?} */\n\n  FirebaseApp.prototype.functions;\n  /** @type {?} */\n\n  FirebaseApp.prototype.remoteConfig;\n}\n/** @type {?} */\n\n\nconst VERSION = /*#__PURE__*/new Version('6.0.4-canary.9a26fbe');\n/**\n * @param {?} options\n * @param {?} zone\n * @param {?=} nameOrConfig\n * @return {?}\n */\n\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n  /** @type {?} */\n  const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  /** @type {?} */\n\n  const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name; // Added any due to some inconsistency between @firebase/app and firebase types\n\n  /** @type {?} */\n\n  const existingApp =\n  /** @type {?} */\n  firebase.apps.filter(\n  /**\n  * @param {?} app\n  * @return {?}\n  */\n  app => app && app.name === config.name)[0]; // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n\n  return (\n    /** @type {?} */\n    existingApp || zone.runOutsideAngular(\n    /**\n    * @return {?}\n    */\n    () => firebase.initializeApp(options,\n    /** @type {?} */\n    config))\n  );\n}\n/** @type {?} */\n\n\nconst FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [FIREBASE_OPTIONS, NgZone, [/*#__PURE__*/new Optional(), FIREBASE_APP_NAME]]\n};\nlet AngularFireModule = /*#__PURE__*/(() => {\n  class AngularFireModule {\n    // tslint:disable-next-line:ban-types\n\n    /**\n     * @param {?} platformId\n     */\n    constructor(platformId) {\n      firebase.registerVersion('angularfire', VERSION.full, platformId.toString());\n      firebase.registerVersion('angular', VERSION$1.full);\n    }\n    /**\n     * @param {?} options\n     * @param {?=} nameOrConfig\n     * @return {?}\n     */\n\n\n    static initializeApp(options, nameOrConfig) {\n      return {\n        ngModule: AngularFireModule,\n        providers: [{\n          provide: FIREBASE_OPTIONS,\n          useValue: options\n        }, {\n          provide: FIREBASE_APP_NAME,\n          useValue: nameOrConfig\n        }]\n      };\n    }\n\n  }\n\n  AngularFireModule.ɵfac = function AngularFireModule_Factory(t) {\n    return new (t || AngularFireModule)(ɵngcc0.ɵɵinject(PLATFORM_ID));\n  };\n\n  AngularFireModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireModule\n  });\n  AngularFireModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [FIREBASE_APP_PROVIDER]\n  });\n  /** @nocollapse */\n\n  return AngularFireModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, VERSION, ɵAngularFireSchedulers, ɵBlockUntilFirstOperator, ɵZoneScheduler, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy }; //# sourceMappingURL=angular-fire.js.map","map":null,"metadata":{},"sourceType":"module"}