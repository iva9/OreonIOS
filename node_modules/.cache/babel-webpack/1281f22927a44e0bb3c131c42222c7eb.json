{"ast":null,"code":"import { Observable, of, from } from 'rxjs';\nimport { map, observeOn, switchMap } from 'rxjs/operators';\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport 'firebase/storage';\nimport firebase from 'firebase/app';\nimport { registerStorage } from '@firebase/storage';\n/**\n * @fileoverview added by tsickle\n * Generated from: observable/fromTask.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} task\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction fromTask(task) {\n  return new Observable(\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n  subscriber => {\n    /** @type {?} */\n    const progress =\n    /**\n    * @param {?} snap\n    * @return {?}\n    */\n    snap => subscriber.next(snap);\n    /** @type {?} */\n\n\n    const error =\n    /**\n    * @param {?} e\n    * @return {?}\n    */\n    e => subscriber.error(e);\n    /** @type {?} */\n\n\n    const complete =\n    /**\n    * @return {?}\n    */\n    () => subscriber.complete();\n\n    task.on('state_changed', progress, error,\n    /**\n    * @return {?}\n    */\n    () => {\n      progress(task.snapshot);\n      complete();\n    });\n    return (\n      /**\n      * @return {?}\n      */\n      () => task.cancel()\n    );\n  });\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: task.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction AngularFireUploadTask() {}\n\nif (false) {\n  /** @type {?} */\n  AngularFireUploadTask.prototype.task;\n  /**\n   * @return {?}\n   */\n\n  AngularFireUploadTask.prototype.snapshotChanges = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.percentageChanges = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.pause = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.cancel = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.resume = function () {};\n  /**\n   * @param {?=} onFulfilled\n   * @param {?=} onRejected\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.then = function (onFulfilled, onRejected) {};\n  /**\n   * @param {?} onRejected\n   * @return {?}\n   */\n\n\n  AngularFireUploadTask.prototype.catch = function (onRejected) {};\n}\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n * @param {?} task\n * @return {?}\n */\n\n\nfunction createUploadTask(task) {\n  /** @type {?} */\n  const inner$ = fromTask(task);\n  return {\n    task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges:\n    /**\n    * @return {?}\n    */\n    () => inner$,\n    percentageChanges:\n    /**\n    * @return {?}\n    */\n    () => inner$.pipe(map(\n    /**\n    * @param {?} s\n    * @return {?}\n    */\n    s => s.bytesTransferred / s.totalBytes * 100))\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: ref.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction AngularFireStorageReference() {}\n\nif (false) {\n  /**\n   * @return {?}\n   */\n  AngularFireStorageReference.prototype.getDownloadURL = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.getMetadata = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.delete = function () {};\n  /**\n   * @param {?} path\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.child = function (path) {};\n  /**\n   * @param {?} meta\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.updateMetadata = function (meta) {};\n  /**\n   * @param {?} data\n   * @param {?=} metadata\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.put = function (data, metadata) {};\n  /**\n   * @param {?} data\n   * @param {?=} format\n   * @param {?=} metadata\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.putString = function (data, format, metadata) {};\n  /**\n   * @return {?}\n   */\n\n\n  AngularFireStorageReference.prototype.listAll = function () {};\n}\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n * @param {?} ref\n * @param {?} schedulers\n * @param {?} keepUnstableUntilFirst\n * @return {?}\n */\n\n\nfunction createStorageRef(ref, schedulers, keepUnstableUntilFirst) {\n  return {\n    getDownloadURL:\n    /**\n    * @return {?}\n    */\n    () => of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n    /**\n    * @return {?}\n    */\n    () => ref.getDownloadURL()), keepUnstableUntilFirst),\n    getMetadata:\n    /**\n    * @return {?}\n    */\n    () => of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n    /**\n    * @return {?}\n    */\n    () => ref.getMetadata()), keepUnstableUntilFirst),\n    delete:\n    /**\n    * @return {?}\n    */\n    () => from(ref.delete()),\n    child:\n    /**\n    * @param {?} path\n    * @return {?}\n    */\n    path => createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst),\n    updateMetadata:\n    /**\n    * @param {?} meta\n    * @return {?}\n    */\n    meta => from(ref.updateMetadata(meta)),\n    put:\n    /**\n    * @param {?} data\n    * @param {?=} metadata\n    * @return {?}\n    */\n    (data, metadata) => {\n      /** @type {?} */\n      const task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString:\n    /**\n    * @param {?} data\n    * @param {?=} format\n    * @param {?=} metadata\n    * @return {?}\n    */\n    (data, format, metadata) => {\n      /** @type {?} */\n      const task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    listAll:\n    /**\n    * @return {?}\n    */\n    () => from(ref.listAll())\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: storage.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst BUCKET = /*#__PURE__*/new InjectionToken('angularfire2.storageBucket');\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\n\nlet AngularFireStorage = /*#__PURE__*/(() => {\n  class AngularFireStorage {\n    /**\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} storageBucket\n     * @param {?} platformId\n     * @param {?} zone\n     */\n    constructor(options, nameOrConfig, storageBucket, // tslint:disable-next-line:ban-types\n    platformId, zone) {\n      this.schedulers = new ɵAngularFireSchedulers(zone);\n      this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n      this.storage = zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n\n        if (registerStorage) {\n          registerStorage(\n          /** @type {?} */\n          firebase);\n        }\n\n        return app.storage(storageBucket || undefined);\n      });\n    }\n    /**\n     * @param {?} path\n     * @return {?}\n     */\n\n\n    ref(path) {\n      return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);\n    }\n    /**\n     * @param {?} path\n     * @param {?} data\n     * @param {?=} metadata\n     * @return {?}\n     */\n\n\n    upload(path, data, metadata) {\n      /** @type {?} */\n      const storageRef = this.storage.ref(path);\n      /** @type {?} */\n\n      const ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);\n      return ref.put(data, metadata);\n    }\n\n  }\n\n  AngularFireStorage.ɵfac = function AngularFireStorage_Factory(t) {\n    return new (t || AngularFireStorage)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(BUCKET, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  AngularFireStorage.ɵprov = ɵɵdefineInjectable({\n    factory: function AngularFireStorage_Factory() {\n      return new AngularFireStorage(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(BUCKET, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone));\n    },\n    token: AngularFireStorage,\n    providedIn: \"any\"\n  });\n  return AngularFireStorage;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  AngularFireStorage.prototype.storage;\n  /** @type {?} */\n\n  AngularFireStorage.prototype.keepUnstableUntilFirst;\n  /** @type {?} */\n\n  AngularFireStorage.prototype.schedulers;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: storage.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet AngularFireStorageModule = /*#__PURE__*/(() => {\n  class AngularFireStorageModule {}\n\n  AngularFireStorageModule.ɵfac = function AngularFireStorageModule_Factory(t) {\n    return new (t || AngularFireStorageModule)();\n  };\n\n  AngularFireStorageModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireStorageModule\n  });\n  AngularFireStorageModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [AngularFireStorage]\n  });\n  return AngularFireStorageModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-storage.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, createStorageRef, createUploadTask, fromTask }; //# sourceMappingURL=angular-fire-storage.js.map","map":null,"metadata":{},"sourceType":"module"}