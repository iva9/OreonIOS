{"ast":null,"code":"import { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, of, merge } from 'rxjs';\nimport { map, share, switchMap, scan, distinctUntilChanged, withLatestFrom, skipWhile } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport 'firebase/database';\nimport { registerDatabase } from '@firebase/database';\nimport firebase from 'firebase/app';\n/**\n * @fileoverview added by tsickle\n * Generated from: utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} value\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isFirebaseDataSnapshot(value) {\n  return typeof value.exportVal === 'function';\n}\n/**\n * @param {?} obj\n * @return {?}\n */\n\n\nfunction isNil(obj) {\n  return obj === undefined || obj === null;\n}\n/**\n * @param {?} value\n * @return {?}\n */\n\n\nfunction isFirebaseRef(value) {\n  return typeof value.set === 'function';\n}\n/**\n * Returns a database reference given a Firebase App and an\n * absolute or relative path.\n * @param {?} database - Firebase Database\n * @param {?} pathRef - Database path, relative or absolute\n * @return {?}\n */\n\n\nfunction getRef(database, pathRef) {\n  // if a db ref was passed in, just return it\n  return isFirebaseRef(pathRef) ?\n  /** @type {?} */\n  pathRef : database.ref(\n  /** @type {?} */\n  pathRef);\n}\n/**\n * @param {?} item\n * @param {?} cases\n * @return {?}\n */\n\n\nfunction checkOperationCases(item, cases) {\n  if (isString(item)) {\n    return cases.stringCase();\n  } else if (isFirebaseRef(item)) {\n    return cases.firebaseCase();\n  } else if (isFirebaseDataSnapshot(item)) {\n    return cases.snapshotCase();\n  }\n\n  throw new Error(`Expects a string, snapshot, or reference. Got: ${typeof item}`);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: observable/fromRef.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template T\n */\n\n\nfunction SnapshotPrevKey() {}\n\nif (false) {\n  /** @type {?} */\n  SnapshotPrevKey.prototype.snapshot;\n  /** @type {?} */\n\n  SnapshotPrevKey.prototype.prevKey;\n}\n/**\n * Create an observable from a Database Reference or Database Query.\n * @template T\n * @param {?} ref Database Reference\n * @param {?} event Listen event type ('value', 'added', 'changed', 'removed', 'moved')\n * @param {?=} listenType 'on' or 'once'\n * @param {?=} scheduler - Rxjs scheduler\n * @return {?}\n */\n\n\nfunction fromRef(ref, event, listenType = 'on', scheduler = asyncScheduler) {\n  return new Observable(\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n  subscriber => {\n    /** @type {?} */\n    let fn = null;\n    fn = ref[listenType](event,\n    /**\n    * @param {?} snapshot\n    * @param {?} prevKey\n    * @return {?}\n    */\n    (snapshot, prevKey) => {\n      scheduler.schedule(\n      /**\n      * @return {?}\n      */\n      () => {\n        subscriber.next({\n          snapshot,\n          prevKey\n        });\n      });\n\n      if (listenType === 'once') {\n        scheduler.schedule(\n        /**\n        * @return {?}\n        */\n        () => subscriber.complete());\n      }\n    },\n    /**\n    * @param {?} err\n    * @return {?}\n    */\n    err => {\n      scheduler.schedule(\n      /**\n      * @return {?}\n      */\n      () => subscriber.error(err));\n    });\n\n    if (listenType === 'on') {\n      return {\n        /**\n         * @return {?}\n         */\n        unsubscribe() {\n          if (fn != null) {\n            ref.off(event, fn);\n          }\n        }\n\n      };\n    } else {\n      return {\n        /**\n         * @return {?}\n         */\n        unsubscribe() {}\n\n      };\n    }\n  }).pipe(map(\n  /**\n  * @param {?} payload\n  * @return {?}\n  */\n  payload => {\n    const {\n      snapshot,\n      prevKey\n    } = payload;\n    /** @type {?} */\n\n    let key = null;\n\n    if (snapshot.exists()) {\n      key = snapshot.key;\n    }\n\n    return {\n      type: event,\n      payload: snapshot,\n      prevKey,\n      key\n    };\n  }), share());\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: list/changes.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} ref\n * @param {?} events\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction listChanges(ref, events, scheduler) {\n  return fromRef(ref, 'value', 'once', scheduler).pipe(switchMap(\n  /**\n  * @param {?} snapshotAction\n  * @return {?}\n  */\n  snapshotAction => {\n    /** @type {?} */\n    const childEvent$ = [of(snapshotAction)];\n    events.forEach(\n    /**\n    * @param {?} event\n    * @return {?}\n    */\n    event => childEvent$.push(fromRef(ref, event, 'on', scheduler)));\n    return merge(...childEvent$).pipe(scan(buildView, []));\n  }), distinctUntilChanged());\n}\n/**\n * @template T\n * @param {?} changes\n * @param {?} key\n * @return {?}\n */\n\n\nfunction positionFor(changes, key) {\n  /** @type {?} */\n  const len = changes.length;\n\n  for (let i = 0; i < len; i++) {\n    if (changes[i].payload.key === key) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * @template T\n * @param {?} changes\n * @param {?=} prevKey\n * @return {?}\n */\n\n\nfunction positionAfter(changes, prevKey) {\n  if (isNil(prevKey)) {\n    return 0;\n  } else {\n    /** @type {?} */\n    const i = positionFor(changes, prevKey);\n\n    if (i === -1) {\n      return changes.length;\n    } else {\n      return i + 1;\n    }\n  }\n}\n/**\n * @param {?} current\n * @param {?} action\n * @return {?}\n */\n\n\nfunction buildView(current, action) {\n  const {\n    payload,\n    prevKey,\n    key\n  } = action;\n  /** @type {?} */\n\n  const currentKeyPosition = positionFor(current, key);\n  /** @type {?} */\n\n  const afterPreviousKeyPosition = positionAfter(current, prevKey);\n\n  switch (action.type) {\n    case 'value':\n      if (action.payload && action.payload.exists()) {\n        /** @type {?} */\n        let prevKey = null;\n        action.payload.forEach(\n        /**\n        * @param {?} payload\n        * @return {?}\n        */\n        payload => {\n          /** @type {?} */\n          const action = {\n            payload,\n            type: 'value',\n            prevKey,\n            key: payload.key\n          };\n          prevKey = payload.key;\n          current = [...current, action];\n          return false;\n        });\n      }\n\n      return current;\n\n    case 'child_added':\n      if (currentKeyPosition > -1) {\n        // check that the previouskey is what we expect, else reorder\n\n        /** @type {?} */\n        const previous = current[currentKeyPosition - 1];\n\n        if ((previous && previous.key || null) !== prevKey) {\n          current = current.filter(\n          /**\n          * @param {?} x\n          * @return {?}\n          */\n          x => x.payload.key !== payload.key);\n          current.splice(afterPreviousKeyPosition, 0, action);\n        }\n      } else if (prevKey == null) {\n        return [action, ...current];\n      } else {\n        current = current.slice();\n        current.splice(afterPreviousKeyPosition, 0, action);\n      }\n\n      return current;\n\n    case 'child_removed':\n      return current.filter(\n      /**\n      * @param {?} x\n      * @return {?}\n      */\n      x => x.payload.key !== payload.key);\n\n    case 'child_changed':\n      return current.map(\n      /**\n      * @param {?} x\n      * @return {?}\n      */\n      x => x.payload.key === key ? action : x);\n\n    case 'child_moved':\n      if (currentKeyPosition > -1) {\n        /** @type {?} */\n        const data = current.splice(currentKeyPosition, 1)[0];\n        current = current.slice();\n        current.splice(afterPreviousKeyPosition, 0, data);\n        return current;\n      }\n\n      return current;\n    // default will also remove null results\n\n    default:\n      return current;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: list/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?=} events\n * @return {?}\n */\n\n\nfunction validateEventsArray(events) {\n  if (isNil(events) || events.length === 0) {\n    events = ['child_added', 'child_removed', 'child_changed', 'child_moved'];\n  }\n\n  return events;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: list/snapshot-changes.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} query\n * @param {?=} events\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction snapshotChanges(query, events, scheduler) {\n  events = validateEventsArray(events);\n  return listChanges(query, events, scheduler);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: list/state-changes.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} query\n * @param {?=} events\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction stateChanges(query, events, scheduler) {\n  events = validateEventsArray(events);\n  /** @type {?} */\n\n  const childEvent$ = events.map(\n  /**\n  * @param {?} event\n  * @return {?}\n  */\n  event => fromRef(query, event, 'on', scheduler));\n  return merge(...childEvent$);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: list/audit-trail.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} query\n * @param {?=} events\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction auditTrail(query, events, scheduler) {\n  /** @type {?} */\n  const auditTrail$ = stateChanges(query, events).pipe(scan(\n  /**\n  * @param {?} current\n  * @param {?} action\n  * @return {?}\n  */\n  (current, action) => [...current, action], []));\n  return waitForLoaded(query, auditTrail$, scheduler);\n}\n/**\n * @record\n */\n\n\nfunction LoadedMetadata() {}\n\nif (false) {\n  /** @type {?} */\n  LoadedMetadata.prototype.data;\n  /** @type {?} */\n\n  LoadedMetadata.prototype.lastKeyToLoad;\n}\n/**\n * @template T\n * @param {?} query\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction loadedData(query, scheduler) {\n  // Create an observable of loaded values to retrieve the\n  // known dataset. This will allow us to know what key to\n  // emit the \"whole\" array at when listening for child events.\n  return fromRef(query, 'value', 'on', scheduler).pipe(map(\n  /**\n  * @param {?} data\n  * @return {?}\n  */\n  data => {\n    // Store the last key in the data set\n\n    /** @type {?} */\n    let lastKeyToLoad; // Loop through loaded dataset to find the last key\n\n    data.payload.forEach(\n    /**\n    * @param {?} child\n    * @return {?}\n    */\n    child => {\n      lastKeyToLoad = child.key;\n      return false;\n    }); // return data set and the current last key loaded\n\n    return {\n      data,\n      lastKeyToLoad\n    };\n  }));\n}\n/**\n * @template T\n * @param {?} query\n * @param {?} action$\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction waitForLoaded(query, action$, scheduler) {\n  /** @type {?} */\n  const loaded$ = loadedData(query, scheduler);\n  return loaded$.pipe(withLatestFrom(action$), // Get the latest values from the \"loaded\" and \"child\" datasets\n  // We can use both datasets to form an array of the latest values.\n  map(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  ([loaded, actions]) => {\n    // Store the last key in the data set\n\n    /** @type {?} */\n    const lastKeyToLoad = loaded.lastKeyToLoad; // Store all child keys loaded at this point\n\n    /** @type {?} */\n\n    const loadedKeys = actions.map(\n    /**\n    * @param {?} snap\n    * @return {?}\n    */\n    snap => snap.key);\n    return {\n      actions,\n      lastKeyToLoad,\n      loadedKeys\n    };\n  }), // This is the magical part, only emit when the last load key\n  // in the dataset has been loaded by a child event. At this point\n  // we can assume the dataset is \"whole\".\n  skipWhile(\n  /**\n  * @param {?} meta\n  * @return {?}\n  */\n  meta => meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1), // Pluck off the meta data because the user only cares\n  // to iterate through the snapshots\n  map(\n  /**\n  * @param {?} meta\n  * @return {?}\n  */\n  meta => meta.actions));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: list/data-operation.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} ref\n * @param {?} operation\n * @return {?}\n */\n\n\nfunction createDataOperationMethod(ref, operation) {\n  return (\n    /**\n    * @template T\n    * @param {?} item\n    * @param {?} value\n    * @return {?}\n    */\n    function dataOperation(item, value) {\n      return checkOperationCases(item, {\n        stringCase:\n        /**\n        * @return {?}\n        */\n        () => ref.child(\n        /** @type {?} */\n        item)[operation](value),\n        firebaseCase:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        item[operation](value),\n        snapshotCase:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        item.ref[operation](value)\n      });\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: list/remove.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// TODO(davideast): Find out why TS thinks this returns firebase.Primise\n// instead of Promise.\n\n/**\n * @template T\n * @param {?} ref\n * @return {?}\n */\n\n\nfunction createRemoveMethod(ref) {\n  return (\n    /**\n    * @param {?=} item\n    * @return {?}\n    */\n    function remove(item) {\n      if (!item) {\n        return ref.remove();\n      }\n\n      return checkOperationCases(item, {\n        stringCase:\n        /**\n        * @return {?}\n        */\n        () => ref.child(\n        /** @type {?} */\n        item).remove(),\n        firebaseCase:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        item.remove(),\n        snapshotCase:\n        /**\n        * @return {?}\n        */\n        () =>\n        /** @type {?} */\n        item.ref.remove()\n      });\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: list/create-reference.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} query\n * @param {?} afDatabase\n * @return {?}\n */\n\n\nfunction createListReference(query, afDatabase) {\n  /** @type {?} */\n  const outsideAngularScheduler = afDatabase.schedulers.outsideAngular;\n  /** @type {?} */\n\n  const refInZone = afDatabase.schedulers.ngZone.run(\n  /**\n  * @return {?}\n  */\n  () => query.ref);\n  return {\n    query,\n    update: createDataOperationMethod(refInZone, 'update'),\n    set: createDataOperationMethod(refInZone, 'set'),\n    push:\n    /**\n    * @param {?} data\n    * @return {?}\n    */\n    data => refInZone.push(data),\n    remove: createRemoveMethod(refInZone),\n\n    /**\n     * @param {?=} events\n     * @return {?}\n     */\n    snapshotChanges(events) {\n      return snapshotChanges(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);\n    },\n\n    /**\n     * @param {?=} events\n     * @return {?}\n     */\n    stateChanges(events) {\n      return stateChanges(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);\n    },\n\n    /**\n     * @param {?=} events\n     * @return {?}\n     */\n    auditTrail(events) {\n      return auditTrail(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);\n    },\n\n    /**\n     * @param {?=} events\n     * @return {?}\n     */\n    valueChanges(events) {\n      /** @type {?} */\n      const snapshotChanges$ = snapshotChanges(query, events, outsideAngularScheduler);\n      return snapshotChanges$.pipe(map(\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n      actions => actions.map(\n      /**\n      * @param {?} a\n      * @return {?}\n      */\n      a =>\n      /** @type {?} */\n      a.payload.val())), afDatabase.keepUnstableUntilFirst);\n    }\n\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: object/snapshot-changes.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} query\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction createObjectSnapshotChanges(query, scheduler) {\n  return (\n    /**\n    * @return {?}\n    */\n    function snapshotChanges() {\n      return fromRef(query, 'value', 'on', scheduler);\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: object/create-reference.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} query\n * @param {?} afDatabase\n * @return {?}\n */\n\n\nfunction createObjectReference(query, afDatabase) {\n  return {\n    query,\n\n    /**\n     * @template T\n     * @return {?}\n     */\n    snapshotChanges() {\n      return createObjectSnapshotChanges(query, afDatabase.schedulers.outsideAngular)().pipe(afDatabase.keepUnstableUntilFirst);\n    },\n\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    update(data) {\n      return (\n        /** @type {?} */\n        query.ref.update(\n        /** @type {?} */\n        data)\n      );\n    },\n\n    /**\n     * @param {?} data\n     * @return {?}\n     */\n    set(data) {\n      return (\n        /** @type {?} */\n        query.ref.set(data)\n      );\n    },\n\n    /**\n     * @return {?}\n     */\n    remove() {\n      return (\n        /** @type {?} */\n        query.ref.remove()\n      );\n    },\n\n    /**\n     * @template T\n     * @return {?}\n     */\n    valueChanges() {\n      /** @type {?} */\n      const snapshotChanges$ = createObjectSnapshotChanges(query, afDatabase.schedulers.outsideAngular)();\n      return snapshotChanges$.pipe(afDatabase.keepUnstableUntilFirst, map(\n      /**\n      * @param {?} action\n      * @return {?}\n      */\n      action => action.payload.exists() ?\n      /** @type {?} */\n      action.payload.val() : null));\n    }\n\n  };\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: database.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst URL = /*#__PURE__*/new InjectionToken('angularfire2.realtimeDatabaseURL');\nlet AngularFireDatabase = /*#__PURE__*/(() => {\n  class AngularFireDatabase {\n    /**\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} databaseURL\n     * @param {?} platformId\n     * @param {?} zone\n     */\n    constructor(options, nameOrConfig, databaseURL, // tslint:disable-next-line:ban-types\n    platformId, zone) {\n      this.schedulers = new ɵAngularFireSchedulers(zone);\n      this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n      this.database = zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n\n        if (registerDatabase) {\n          registerDatabase(\n          /** @type {?} */\n          firebase);\n        }\n\n        return app.database(databaseURL || undefined);\n      });\n    }\n    /**\n     * @template T\n     * @param {?} pathOrRef\n     * @param {?=} queryFn\n     * @return {?}\n     */\n\n\n    list(pathOrRef, queryFn) {\n      /** @type {?} */\n      const ref = getRef(this.database, pathOrRef);\n      /** @type {?} */\n\n      let query = ref;\n\n      if (queryFn) {\n        query = queryFn(ref);\n      }\n\n      return createListReference(query, this);\n    }\n    /**\n     * @template T\n     * @param {?} pathOrRef\n     * @return {?}\n     */\n\n\n    object(pathOrRef) {\n      /** @type {?} */\n      const ref = getRef(this.database, pathOrRef);\n      return createObjectReference(ref, this);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    createPushId() {\n      return this.database.ref().push().key;\n    }\n\n  }\n\n  AngularFireDatabase.ɵfac = function AngularFireDatabase_Factory(t) {\n    return new (t || AngularFireDatabase)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(URL, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  AngularFireDatabase.ɵprov = ɵɵdefineInjectable({\n    factory: function AngularFireDatabase_Factory() {\n      return new AngularFireDatabase(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(URL, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone));\n    },\n    token: AngularFireDatabase,\n    providedIn: \"any\"\n  });\n  return AngularFireDatabase;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  AngularFireDatabase.prototype.database;\n  /** @type {?} */\n\n  AngularFireDatabase.prototype.schedulers;\n  /** @type {?} */\n\n  AngularFireDatabase.prototype.keepUnstableUntilFirst;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: database.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet AngularFireDatabaseModule = /*#__PURE__*/(() => {\n  class AngularFireDatabaseModule {}\n\n  AngularFireDatabaseModule.ɵfac = function AngularFireDatabaseModule_Factory(t) {\n    return new (t || AngularFireDatabaseModule)();\n  };\n\n  AngularFireDatabaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireDatabaseModule\n  });\n  AngularFireDatabaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [AngularFireDatabase]\n  });\n  return AngularFireDatabaseModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-database.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireDatabase, AngularFireDatabaseModule, URL, auditTrail, createListReference, fromRef, listChanges, snapshotChanges, stateChanges }; //# sourceMappingURL=angular-fire-database.js.map","map":null,"metadata":{},"sourceType":"module"}